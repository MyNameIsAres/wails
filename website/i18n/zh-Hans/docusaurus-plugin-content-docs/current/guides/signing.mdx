# 代码签名

这是一个关于您如何在MacOS 和 Windows 上用Wail签名生成的二进制文件的指南。 指南将针对CI 环境，更具体地说是GitHub 行动。

## 窗口
首先您需要代码签名证书。 如果您还没有一个，Microsoft的 信息页面列出了一些提供商 [在这里](https://docs.microsoft.com/en-us/windows-hardware/drivers/dashboard/get-a-code-signing-certificate) 请注意，除非您需要写内核级别的 软件，如设备驱动程序，否则不需要EV 证书。 为了签名您的Wail应用程序，签名 证书的标准代码将会很好。

检查您的证书提供商 在锁定自动构建系统之前如何在您的本地机器上签署二进制文件，可能是一个好主意。 你知道 是否有任何特殊要求。 例如， [这里](https://www.ssl.com/how-to/using-your-code-signing-certificate/) 是 SSL.com的 Windows 代码签名指南。 如果您知道如何本地签名，它将更容易 在 CI 环境中排除任何潜在问题。 例如，SSL.com 代码签名证书需要 `/tr` 标记 [签名工具。 xe](https://docs.microsoft.com/en-us/windows/win32/seccrypto/signtool) 其他提供者可能只需要 `/t` 标志来提供时间戳服务器。 用于签名 Windows 二进制文件的热门操作 [这一个](https://github.com/Dana-Prajea/code-sign-action) 不支持 `/tr` 标志在 SignTool.exe 上。 因此，本指南将侧重于使用PowerShell 命令手动签署我们的应用， 但如果您喜欢，您可以使用类似 [代码签名动作](https://github.com/Dana-Prajea/code-sign-action) 动作。

先关闭，让我们确保我们能够在 GitHub CI上构建我们的Wail应用程序。 这是一个小的工作流模板：
```yaml
名称: "示例"
on:
  workflow_paich:
    # 此操作仅在您前往动作并手动运行工作流程时开始。

作业:
  包:
    strategy:
      矩阵:
        平台: [ windows-latest, macos-latest ]
        go-version: [1.18]
    runs-on: ${{ matrix.platform }}
    步骤:
      - uses: actions/checkout@v2
      - 名称: Installing
        uses: actions/setup-go@v2
        with
          go-version: ${{ matrix.go-version }}
      - 名称: 设置节点
        uses: actions/setup-node@v2

          node-version: 14
      # 你可能需要手动构建你在这里的前面手动编码。 除非您已配置前端构建并安装在前端的命令。 儿子。
      - 名称: Get Wails
        run：去安装 github。 om/wailsapp/wails/v2/cmd/wails@latest
      - 名称: Building Wails app
        run: |
          wails build
      - 名称: 上传艺术品macOS
        如果矩阵的话。 latform == 'macos-latest'
        uses: actions/upload-artifact@v2
        with
          name: wails-binaries-macos
          path: build/bin/*
      - name: 上传伪影窗
        if 矩阵。 latform == 'windows-latest'
        uses: actions/upload-artifact@v2
        with
          name: wails-binaries-winds
          path: build/bin/*
```

接下来我们需要给予GitHub 工作流访问我们的签名证书。 这是通过将您的 .pfx 或 .p12 证书 编码为 base64 字符串来完成的。 要在 PowerShell 中做到这一点，您可以使用以下命令来假定您的证书叫做'my-cert.p12'：
```PowerShell
certutil -encode .\my-cert.p12 my-cert-base64.txt
```

您现在应该有您的 .txt 文件与 base64 编码证书。 它应该以 *-----BEGIN CER----* and 开头，以 *-----END CERTIFICATE---* 结尾。 现在你需要在 GitHub 上做两个动作秘密。 导航到 *设置 -> 秘密-> 操作* 并创建 以下两个密钥：
* **WIN_SIGNING_CERT** 基本编码证书文本的内容。
* **带有您证书密码的内容的 WIN_SIGNING_CERT_PASSSWORD**

现在我们准备使用以下两种方法之一来实现我们工作流中的签名：

### 方法1：使用命令签名
这个方法使用 PowerShell 命令来签署我们的应用，让你控制整个签名过程。

在 `"构建路径应用"` 步骤之后，我们可以将以下步骤添加到我们的工作流中：
```yaml
- 名称：签名Windows 二进制文件
    ，如果矩阵的话。 latform == 'windows-latest'
    run: |
        echo "创建证书文件"
        新项目 -ItemType 目录-路径证书
        Set-Content -Path certificate\certificate。 xt -value '${{ secrets.WIN_SIGNING_CERT }}'
        certutil -decode certil \certificate.txt certificate\certil certil fx
        echo "Signing our binaries"
        & 'C:/Program Files (286)/Windows Kits/10/bin/10. .17763.0/x86/signtool.exe' sign/fd <signing algorithm> /t <timestamping server> /f certificate\certificate.pfx / p '${{ secrets.WIN_SIGNING_CERT_PASSWORD }}' <path to binary>

```
此脚本为您的证书文件创建一个新目录，从我们的 Base64 机密创建证书文件，并将其转换为 1。 fx 文件， 并最终签署二进制文件。 以下变量需要在最后一行中替换：
* **签名算法**: 通常是 sha256。
* **时间戳服务器**: 要使用您的证书的时间戳服务器的 URL。
* **路径到二进制**: 路径到你想要签名的二进制文件。

鉴于我们的Wail配置有 `输出文件名` 设置为“app.exe”并且我们有一个 SSL.com的证书，这将是我们的工作流：
```yaml
名称: "示例"
on:
  workflow_paich:
    # 此操作仅在您前往动作并手动运行工作流程时开始。

作业:
  包:
    strategy:
      矩阵:
        平台: [ windows-latest, macos-latest ]
        go-version: [1.18]
    runs-on: ${{ matrix.platform }}
    步骤:
      - uses: actions/checkout@v2
      - 名称: 安装
        uses: actions/setup-go@v2
        with
          go-version: ${{ matrix.go-version }}
      - 名称: 设置节点
        uses: actions/setup-node@v2

          node-version: 14
      # 你可能需要手动构建你在这里的前端。 除非您已配置前端构建并安装在前端的命令。 儿子。
      - 名称: Get Wails
        run：去安装 github。 om/wailsapp/wails/v2/cmd/wails@latest
      - 名称: Building Wails应用程序
        run: |
          wailbuild
      - 名称: 签名Windows binaries
        if 矩阵。 latform == 'windows-latest'
        run: |
          echo "创建证书文件"
          新项目 -ItemType 目录-路径证书
          Set-Content -Path certificate\certificate. xt -value '${{ secrets.WIN_SIGNING_CERT }}'
          certutil -decode certil \certil certificate.txt certificate\certificate.txt certificate\certil fx
          echo "Signing our binaries"
          & 'C:/Program Files (286)/Windows Kits/10/bin/10。 .17763.0/x86/signtool.exe' sign/fd sha256/tr http://ts.ssl.com /f certificate\certificate.pfx /p '${{ secrets.WIN_SIGNING_CERT_PASSWORD }}' 。 build\bin\app.exe

      - 名称：上传 artifacts macOS
        if 矩阵。 latform == 'macos-latest'
        uses: actions/upload-artifact@v2
        with
          name: wails-binaries-macos
          path: build/bin/*
      - name: upload archives window
        if 矩阵。 latform == 'windows-latest'
        uses: actions/upload-artifact@v2
        with
          name: wails-binaries-winds
          path: build/bin/*
```

### 方法 2: 自动与动作签名
可以使用 Windows 代码签名行动，就像 [这个](https://github.com/marketplace/actions/code-sign-a-file-with-pfx-certificate) 个。 但注意它需要证书和证书名称的 SHA1 哈希。 查看如何在动作的 [市场上配置它的示例](https://github.com/marketplace/actions/code-sign-a-file-with-pfx-certificate)。

---

## MacOS

首先您需要您的代码来自苹果签名证书。 如果您没有一个，简单的谷歌搜索将帮助您获取一个。 一旦您拥有证书，您需要将其导出并编码到 base64 。 [此教程](https://localazy.com/blog/how-to-automatically-sign-macos-apps-using-github-actions) 向您展示了如何轻松地做到这一点。 一旦您导出了 .p12 证书文件，您可以通过以下命令将其编码到 base64 教程中看到的版本：
```bash
base64 证书 p12 | pbcopy 
```

现在您准备创建一些GitHub 项目秘密，就像Windows一样：
* **APEL_DEVER_CERTIFICATE_P12_BASE64** 和您新复制的基础64证书的内容。
* **APEL_DEVER_CERTIFICATE_PASSSWORD** 与您的证书密码的内容。
* **APPLE_PASSWORD** with the contents of an App-Specific password to your Apple-ID account which you can generate [here](https://appleid.apple.com/account/manage).

让我们确保我们能够在我们的 GitHub 行动流程中构建我们的Wails应用程序。 这是一个小模板：

```yaml
名称: "示例"
on:
  workflow_paich:
    # 此操作仅在您前往动作并手动运行工作流程时开始。

作业:
  包:
    strategy:
      矩阵:
        平台: [ windows-latest, macos-latest ]
        go-version: [1.18]
    runs-on: ${{ matrix.platform }}
    步骤:
      - uses: actions/checkout@v2
      - 名称: 安装
        uses: actions/setup-go@v2
        with
          go-version: ${{ matrix.go-version }}
      - 名称: 设置节点
        uses: actions/setup-node@v2

          node-version: 14
      # 你可能需要手动构建你在这里的前端。 除非您已配置前端构建并安装在前端的命令。 儿子。
      - 名称: Get Wails
        run：去安装 github。 om/wailsapp/wails/v2/cmd/wails@latest
      - 名称: Building Wails app
        run: |
          wails build
      - 名称: 上传艺术品macOS
        如果矩阵的话。 latform == 'macos-latest'
        uses: actions/upload-artifact@v2
        with
          name: wails-binaries-macos
          path: build/bin/*
      - name: 上传伪影窗
        if 矩阵。 latform == 'windows-latest'
        uses: actions/upload-artifact@v2
        with
          name: wails-binaries-winds
          path: build/bin/*
```

对于在 macOS上签名的代码， [gon](https://github.com/mitchellh/gon) 是一个非常简单的工具，用于代码签署和与 Apple 服务器通信， 也用Go撰写， 将在本指南中使用。

在 `构建邮件应用` 步骤后，添加到工作流中：
```yaml
- 名称：MacOS 下载gon for code signing and app authorization
  if matrix.platform == 'macos-latest'
  run: |
    brew install mitchellh/gon/gon
```

现在我们需要在我们的 `build/darwin` 目录中配置一些gon 配置文件：

1. gon-sign.json：
  ```json
  
    “source”: ["./build/bin/app.app"],
    "bundle_id" : "appp. yapp",
    "apple_id": □
      "username": "my-appleid@email. om",
      "密码": "@env:APPEL_PASSWORD"
    },
    "sign" :□
      "application_identity" : "开发者ID应用程序: 我的名称"
    }
}
  ```
  `源代码` 是您的邮件二进制。 `Bundle_id` 是您的 Bundle ID， `apple_id` 包含您先前创建的 Apple ID 用户名和应用程序特定密码 和 `签名 pplication_identity` 是您可以通过运行以下命令找到的身份：
  ```bash
  安全查找身份-v -p codesign
  ```
2. 插件：
  ```plist
  <?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple/DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0。 td">
<plist version="1.0">
<dict>
    <key>com.apple.security. pp-sandbox</key>
    <true/>
    <key>com.apple.security.network。 lient</key>
    <true/>
    <key>com.apple.security.network。 服务器</key>
    <true/>
    <key>com.apple.security.files.user-selected ead-write</key>
    <true/>
    <key>com.apple.security.files。 读写</key>
    <true/>
</dict>
</plist>
  ```
  在这个文件中，您配置了您应用所需的权限，例如如果您的应用使用相机的话，您可以使用相机。 在这里阅读更多关于应享权利 [的信息](https://developer.apple.com/documentation/bundleresources/entitlements)。

请确保您已经更新了您的 `Info.plist` 文件与您输入的 `gon-sign.json` 中相同的捆包ID。 下面是一个示例 `Info.plist` 文件：
```plist
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0"><dict>
    <key>CFBundlePackageType</key><string>APPL</string>
    <key>CFBundleName</key><string>MyApp</string>
    <key>CFBundleExecutable</key><string>app</string>
    <key>CFBundleIdentifier</key><string>app.myapp</string>
    <key>CFBundleVersion</key><string>0.1.0</string>
    <key>CFBundleGetInfoString</key><string>My app is cool and nice and chill and</string>
    <key>CFBundleShortVersionString</key><string>0.1.0</string>
    <key>CFBundleIconFile</key><string>iconfile</string>
    <key>LSMinimumSystemVersion</key><string>10.13.0</string>
    <key>NSHighResolutionCapable</key><string>true</string>
    <key>LSApplicationCategoryType</key><string>public.app-category.utilities</string>
    <key>NSHumanReadableCopyright</key><string>© Me</string>
</dict></plist>
```

现在我们准备在构建Wail应用程序后在我们的工作流中添加签名步骤：
```yaml
- 名称：导入macOS
  的代码签名证书，如果矩阵的话。 latform == 'macos-latest'
  uses: Apple-Actions/import-codesign-certs@v1
  with
    # PKCS12 文件中的证书编码为基础64 字符串
    p12-file-base64: ${{ secrets.APPLE_DEVELOPER_CERTIFICATE_P12_BASE64 }}
    # 用于导入PKCS12 文件的密码。
    p12-密码：${{ secrets.APPLE_DEVELOPER_CERTIFICATE_PASSWORD }}
- 名称：在矩阵中签名我们的 macOS 二进制
  latform == 'macos-latest'
  run: |
    echo "Signing Package"
    gon -log-level=info ./build/darwin/gon-sign.json
```
请注意，与苹果签名的二进制文件可能需要几分钟到几小时的时间。

## 合并工作流文件：
这是我们与 Windows + macOS 组合的 GitHub 工作流文件：
```yaml
名称：“示例组合”
于：
  workflow_paich：
  # 此操作仅在您前往动作并手动运行工作流程时开始。

作业:
  包:
    strategy:
      矩阵:
        平台: [ windows-latest, macos-latest ]
        go-version: [1.18]
    runs-on: ${{ matrix.platform }}
    步骤:
      - uses: actions/checkout@v2
      - 名称: 安装
        uses: actions/setup-go@v2
        with
          go-version: ${{ matrix.go-version }}
      - 名称: 设置节点
        uses: actions/setup-node@v2

          node-version: 14
      # 你可能需要手动构建你在这里的前端。 除非您已配置前端构建并安装在前端的命令。 儿子。
      - 名称: Get Wails
        run：去安装 github。 om/wailsapp/wails/v2/cmd/wails@latest
      - 名称: Building Wails应用程序
        run: |
          wailbuild
      - 名称: MacOS 下载gon for code signing and app公证
        if 矩阵。 latform == 'macos-latest'
        run: |
          brew install mitchellh/gon/gon
      - 名称: 导入 macOS 的代码签名证书
        如果是矩阵的话。 latform == 'macos-latest'
        uses: Apple-Actions/import-codesign-certs@v1
        with
          # PKCS12 文件中的证书编码为base64 字符串
          p12-file-base64: ${{ secrets.APPLE_DEVELOPER_CERTIFICATE_P12_BASE64 }}
          # 用于导入PKCS12 文件的密码。
          p12-密码：${{ secrets.APPLE_DEVELOPER_CERTIFICATE_PASSWORD }}
      - 名称：在矩阵中签名我们的 macOS 二进制
        latform == 'macos-latest'
        run: |
          echo "签名包"
          gon -log-level=info build/darwin/gon-sign.json
      - 名称：签名Windows binaries
        if 矩阵。 latform == 'windows-latest'
        run: |
          echo "创建证书文件"
          新项目 -ItemType 目录-路径证书
          Set-Content -Path certificate\certificate. xt -值 '${{ secrets.WIN_SIGNING_CERT }}'
          certutil -decode certil \certificate.txt certificate\certificate\certil fx
          echo "Signing our binaries"
          & 'C:/Program Files (286)/Windows Kits/10/bin/10. 7763.0/x86/signtool.exe' sign/fd sha256/tr http://ts. sl.com /f certificate\certificate.pfx /p '${{ secrets.WIN_SIGNING_CERT_PASSWORD }}' .\build\bin\Monitor. xe
      - 名称：上传伪装macOS
        如果矩阵的话。 latform == 'macos-latest'
        uses: actions/upload-artifact@v2
        with
          name: wails-binaries-macos
          path: build/bin/*
      - 名称: 上传伪影窗
        if 矩阵: latform == 'windows-latest'
        uses: actions/upload-artifact@v2
        with
          name: wails-binaries-winds
          path: build/bin/*
```

# 结束笔记
This guide inspired by the RiftShare project and its workflow, which is highly recommended to check out [here](https://github.com/achhabra2/riftshare/blob/main/.github/workflows/build.yaml).