# 代码签名

This is a guide on how you can sign your binaries generated with Wails on MacOS and Windows. The guide will target CI environments, more specifically GitHub Actions. 指南将针对CI 环境，更具体地说是GitHub 行动。

## Windows
首先您需要代码签名证书。 如果您还没有一个，Microsoft的 信息页面列出了一些提供商 [在这里](https://docs.microsoft.com/en-us/windows-hardware/drivers/dashboard/get-a-code-signing-certificate) First off you need a code signing certificate. If you do not already have one, Microsoft's info page lists some providers [here](https://docs.microsoft.com/en-us/windows-hardware/drivers/dashboard/get-a-code-signing-certificate). Please note that an EV certificate is not required unless you need to write kernel-level software such as device drivers. For signing your Wails app, a standard code signing certificate will do just fine. 为了签名您的Wail应用程序，签名 证书的标准代码将会很好。

It may be a good idea to check with your certificate provider how to sign your binaries on your local machine before targeting automated build systems, just so you know if there are any special requirements. For instance, [here](https://www.ssl.com/how-to/using-your-code-signing-certificate/) is SSL.com's code signing guide for Windows. If you know how to sign locally, it will be easier to troubleshoot any potential issues in a CI environment. For instance, SSL.com code signing certificates require the `/tr` flag for [SignTool.exe](https://docs.microsoft.com/en-us/windows/win32/seccrypto/signtool) while other providers may only need the `/t` flag for providing the timestamping server. Popular GitHub Actions for signing Windows binaries like [this one](https://github.com/Dana-Prajea/code-sign-action) does not support the `/tr` flag on SignTool.exe. Therefore this guide will focus on signing our app manually with PowerShell commands, but you can use actions like the [code-sign-action](https://github.com/Dana-Prajea/code-sign-action) Action if you prefer. 例如， [这里](https://www.ssl.com/how-to/using-your-code-signing-certificate/) 是 SSL.com的 Windows 代码签名指南。 如果您知道如何本地签名，它将更容易 在 CI 环境中排除任何潜在问题。 例如，SSL.com 代码签名证书需要 `/tr` 标记 [签名工具。 xe](https://docs.microsoft.com/en-us/windows/win32/seccrypto/signtool) 其他提供者可能只需要 `/t` 标志来提供时间戳服务器。 用于签名 Windows 二进制文件的热门操作 [这一个](https://github.com/Dana-Prajea/code-sign-action) 不支持 `/tr` 标志在 SignTool.exe 上。 因此，本指南将侧重于使用PowerShell 命令手动签署我们的应用， 但如果您喜欢，您可以使用类似 [代码签名动作](https://github.com/Dana-Prajea/code-sign-action) 动作。

First off, let's make sure we are able to build our Wails app in our GitHub CI. Here is a small workflow template: 这是一个小的工作流模板：
```yaml
名称: "示例"
on:
  workflow_paich:
    # 此操作仅在您前往动作并手动运行工作流程时开始。

作业:
  包:
    strategy:
      矩阵:
        平台: [ windows-latest, macos-latest ]
        go-version: [1.18]
    runs-on: ${{ matrix.platform }}
    步骤:
      - uses: actions/checkout@v2
      - 名称: Installing
        uses: actions/setup-go@v2
        with
          go-version: ${{ matrix.go-version }}
      - 名称: 设置节点
        uses: actions/setup-node@v2

          node-version: 14
      # 你可能需要手动构建你在这里的前面手动编码。 除非您已配置前端构建并安装在前端的命令。 儿子。
      name: "example"
on:
  workflow_dispatch:
    # This Action only starts when you go to Actions and manually run the workflow.

jobs:
  package:
    strategy:
      matrix:
        platform: [ windows-latest, macos-latest ]
        go-version: [1.18]
    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v2
      - name: Install Go
        uses: actions/setup-go@v2
        with:
          go-version: ${{ matrix.go-version }}
      - name: setup node
        uses: actions/setup-node@v2
        with:
          node-version: 14
      # You may need to manually build you frontend here, unless you have configured frontend build and install commands in wails.json.
      - name: Get Wails
        run: go install github.com/wailsapp/wails/v2/cmd/wails@latest
      - name: Build Wails app
        run: |
          wails build
      - name: upload artifacts macOS
        if: matrix.platform == 'macos-latest'
        uses: actions/upload-artifact@v2
        with:
          name: wails-binaries-macos
          path: build/bin/*
      - name: upload artifacts windows
        if: matrix.platform == 'windows-latest'
        uses: actions/upload-artifact@v2
        with:
          name: wails-binaries-windows
          path: build/bin/*
```

Next we need to give the GitHub workflow access to our signing certificate. This is done by encoding your .pfx or .p12 certificate into a base64 string. To do this in PowerShell, you can use the following command assuming your certificate is called 'my-cert.p12': 这是通过将您的 .pfx 或 .p12 证书 编码为 base64 字符串来完成的。 要在 PowerShell 中做到这一点，您可以使用以下命令来假定您的证书叫做'my-cert.p12'：
```PowerShell
certutil -encode .\my-cert.p12 my-cert-base64.txt
```

您现在应该有您的 .txt 文件与 base64 编码证书。 它应该以 *-----BEGIN CER----* and 开头，以 *-----END CERTIFICATE---* 结尾。 现在你需要在 GitHub 上做两个动作秘密。 导航到 *设置 -> 秘密-> 操作* 并创建 以下两个密钥：
* **WIN_SIGNING_CERT** with the contents of your base64 encoded certificate text.
* **WIN_SIGNING_CERT_PASSWORD** with the contents of your certificate password.

Now we're ready to implement the signing in our workflow using one of the two methods:

### Method 1: signing with commands
This method uses PowerShell commands to sign our app, and leaves you control over the entire signing process.

After the `"Build Wails app"` step, we can add the following step to our workflow:
```yaml
- name: Sign Windows binaries
    if: matrix.platform == 'windows-latest'
    run: |
        echo "Creating certificate file"
        New-Item -ItemType directory -Path certificate
        Set-Content -Path certificate\certificate.txt -Value '${{ secrets.WIN_SIGNING_CERT }}'
        certutil -decode certificate\certificate.txt certificate\certificate.pfx
        echo "Signing our binaries"
        & 'C:/Program Files (x86)/Windows Kits/10/bin/10.0.17763.0/x86/signtool.exe' sign /fd <signing algorithm> /t <timestamping server> /f certificate\certificate.pfx /p '${{ secrets.WIN_SIGNING_CERT_PASSWORD }}' <path to binary>

```
This script creates a new directory for your certificate file, creates the certificate file from our base64 secret, converts it to a .pfx file, and finally signs the binary. The following variables needs to be replaced in the last line: 以下变量需要在最后一行中替换：
* **signing algorithm**: usually sha256.
* **timestamping server**: URL to the timestamping server to use with your certificate.
* **path to binary**: path to the binary you want to sign.

Given that our Wails config has `outputfilename` set to "app.exe" and that we have a certificate from SSL.com, this would be our workflow:
```yaml
名称: "示例"
on:
  workflow_paich:
    # 此操作仅在您前往动作并手动运行工作流程时开始。

作业:
  包:
    strategy:
      矩阵:
        平台: [ windows-latest, macos-latest ]
        go-version: [1.18]
    runs-on: ${{ matrix.platform }}
    步骤:
      - uses: actions/checkout@v2
      - 名称: 安装
        uses: actions/setup-go@v2
        with
          go-version: ${{ matrix.go-version }}
      - 名称: 设置节点
        uses: actions/setup-node@v2

          node-version: 14
      # 你可能需要手动构建你在这里的前端。 除非您已配置前端构建并安装在前端的命令。 儿子。
      name: "example"
on:
  workflow_dispatch:
    # This Action only starts when you go to Actions and manually run the workflow.

jobs:
  package:
    strategy:
      matrix:
        platform: [ windows-latest, macos-latest ]
        go-version: [1.18]
    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v2
      - name: Install Go
        uses: actions/setup-go@v2
        with:
          go-version: ${{ matrix.go-version }}
      - name: setup node
        uses: actions/setup-node@v2
        with:
          node-version: 14
      # You may need to manually build you frontend here, unless you have configured frontend build and install commands in wails.json.
      - name: Get Wails
        run: go install github.com/wailsapp/wails/v2/cmd/wails@latest
      - name: Build Wails app
        run: |
          wails build
      - name: Sign Windows binaries
        if: matrix.platform == 'windows-latest'
        run: |
          echo "Creating certificate file"
          New-Item -ItemType directory -Path certificate
          Set-Content -Path certificate\certificate.txt -Value '${{ secrets.WIN_SIGNING_CERT }}'
          certutil -decode certificate\certificate.txt certificate\certificate.pfx
          echo "Signing our binaries"
          & 'C:/Program Files (x86)/Windows Kits/10/bin/10.0.17763.0/x86/signtool.exe' sign /fd sha256 /tr http://ts.ssl.com /f certificate\certificate.pfx /p '${{ secrets.WIN_SIGNING_CERT_PASSWORD }}' .\build\bin\app.exe

      - name: upload artifacts macOS
        if: matrix.platform == 'macos-latest'
        uses: actions/upload-artifact@v2
        with:
          name: wails-binaries-macos
          path: build/bin/*
      - name: upload artifacts windows
        if: matrix.platform == 'windows-latest'
        uses: actions/upload-artifact@v2
        with:
          name: wails-binaries-windows
          path: build/bin/*
```

### Method 2: automatically signing with Action
It is possible to use a Windows code signing Action like [this](https://github.com/marketplace/actions/code-sign-a-file-with-pfx-certificate) one, but note it requires a SHA1 hash for the certificate and a certificate name. View an example of how to configure it on the Action's [marketplace](https://github.com/marketplace/actions/code-sign-a-file-with-pfx-certificate). 查看如何在动作的 [市场上配置它的示例](https://github.com/marketplace/actions/code-sign-a-file-with-pfx-certificate)。

---

## MacOS

First off you need your code signing certificate from Apple. If you do not have one, a simple Google search will help you acquire one. Once you have your certificate, you need to export it and encode it to base64. [This tutorial](https://localazy.com/blog/how-to-automatically-sign-macos-apps-using-github-actions) shows you how to do that in an easy manner. Once you have exported your .p12 certificate file, you can encode it to base64 as seen in the tutorial with the following command: 如果您没有一个，简单的谷歌搜索将帮助您获取一个。 一旦您拥有证书，您需要将其导出并编码到 base64 。 [此教程](https://localazy.com/blog/how-to-automatically-sign-macos-apps-using-github-actions) 向您展示了如何轻松地做到这一点。 一旦您导出了 .p12 证书文件，您可以通过以下命令将其编码到 base64 教程中看到的版本：
```bash
base64 Certificates.p12 | pbcopy 
```

Now you're ready to create some GitHub project secrets, just as with Windows:
* **APPLE_DEVELOPER_CERTIFICATE_P12_BASE64** with the contents of your newly copied base64 certificate.
* **APPLE_DEVELOPER_CERTIFICATE_PASSWORD** with the contents of your certificate password.
* **APPLE_PASSWORD** with the contents of an App-Specific password to your Apple-ID account which you can generate [here](https://appleid.apple.com/account/manage).

Let's make sure we are able to build our Wails app in our GitHub Action workflow. Here is a small template: 这是一个小模板：

```yaml
名称: "示例"
on:
  workflow_paich:
    # 此操作仅在您前往动作并手动运行工作流程时开始。

作业:
  包:
    strategy:
      矩阵:
        平台: [ windows-latest, macos-latest ]
        go-version: [1.18]
    runs-on: ${{ matrix.platform }}
    步骤:
      - uses: actions/checkout@v2
      - 名称: 安装
        uses: actions/setup-go@v2
        with
          go-version: ${{ matrix.go-version }}
      - 名称: 设置节点
        uses: actions/setup-node@v2

          node-version: 14
      # 你可能需要手动构建你在这里的前端。 除非您已配置前端构建并安装在前端的命令。 儿子。
      name: "example"
on:
  workflow_dispatch:
    # This Action only starts when you go to Actions and manually run the workflow.

jobs:
  package:
    strategy:
      matrix:
        platform: [ windows-latest, macos-latest ]
        go-version: [1.18]
    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v2
      - name: Install Go
        uses: actions/setup-go@v2
        with:
          go-version: ${{ matrix.go-version }}
      - name: setup node
        uses: actions/setup-node@v2
        with:
          node-version: 14
      # You may need to manually build you frontend here, unless you have configured frontend build and install commands in wails.json.
      - name: Get Wails
        run: go install github.com/wailsapp/wails/v2/cmd/wails@latest
      - name: Build Wails app
        run: |
          wails build
      - name: upload artifacts macOS
        if: matrix.platform == 'macos-latest'
        uses: actions/upload-artifact@v2
        with:
          name: wails-binaries-macos
          path: build/bin/*
      - name: upload artifacts windows
        if: matrix.platform == 'windows-latest'
        uses: actions/upload-artifact@v2
        with:
          name: wails-binaries-windows
          path: build/bin/*
```

For code signing on macOS, [gon](https://github.com/mitchellh/gon) is a very handy tool for code signing and communicating with Apple servers, also written in Go, and will be used in this guide.

After the `Build Wails app` step, add the following to the workflow:
```yaml
- name: MacOS download gon for code signing and app notarization
  if: matrix.platform == 'macos-latest'
  run: |
    brew install mitchellh/gon/gon
```

Now we need to configure some gon config files in our `build/darwin` directory:

1. gon-sign.json:
  ```json
  {
    "source" : ["./build/bin/app.app"],
    "bundle_id" : "app.myapp",
    "apple_id": {
      "username": "my-appleid@email.com",
      "password": "@env:APPLE_PASSWORD"
    },
    "sign" :{
      "application_identity" : "Developer ID Application: My Name"
    }
  }
  ```
  Where `source` is your Wails binary, `bundle_id` is your bundle ID, `apple_id` contains your Apple ID username and App-Specific password which you created earlier, and `sign.application_identity` is your identity which you can find by running the following command:
  ```bash
  security find-identity -v -p codesigning
  ```
2. entitlements.plist:
  ```plist
  <?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>com.apple.security.app-sandbox</key>
    <true/>
    <key>com.apple.security.network.client</key>
    <true/>
    <key>com.apple.security.network.server</key>
    <true/>
    <key>com.apple.security.files.user-selected.read-write</key>
    <true/>
    <key>com.apple.security.files.downloads.read-write</key>
    <true/>
</dict>
</plist>
  ```
  In this file you configure the entitlements you need for you app, e.g. camera permissions if your app uses the camera. Read more about entitlements [here](https://developer.apple.com/documentation/bundleresources/entitlements). 在这里阅读更多关于应享权利 [的信息](https://developer.apple.com/documentation/bundleresources/entitlements)。

Make sure you have updated your `Info.plist` file with the same bundle ID as you entered in `gon-sign.json`. Here's an example `Info.plist` file: 下面是一个示例 `Info.plist` 文件：
```plist
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0"><dict>
    <key>CFBundlePackageType</key><string>APPL</string>
    <key>CFBundleName</key><string>MyApp</string>
    <key>CFBundleExecutable</key><string>app</string>
    <key>CFBundleIdentifier</key><string>app.myapp</string>
    <key>CFBundleVersion</key><string>0.1.0</string>
    <key>CFBundleGetInfoString</key><string>My app is cool and nice and chill and</string>
    <key>CFBundleShortVersionString</key><string>0.1.0</string>
    <key>CFBundleIconFile</key><string>iconfile</string>
    <key>LSMinimumSystemVersion</key><string>10.13.0</string>
    <key>NSHighResolutionCapable</key><string>true</string>
    <key>LSApplicationCategoryType</key><string>public.app-category.utilities</string>
    <key>NSHumanReadableCopyright</key><string>© Me</string>
</dict></plist>
```

Now we're ready to add the signing step in our workflow after building the Wails app:
```yaml
- name: Import Code-Signing Certificates for macOS
  if: matrix.platform == 'macos-latest'
  uses: Apple-Actions/import-codesign-certs@v1
  with:
    # The certificates in a PKCS12 file encoded as a base64 string
    p12-file-base64: ${{ secrets.APPLE_DEVELOPER_CERTIFICATE_P12_BASE64 }}
    # The password used to import the PKCS12 file.
    p12-password: ${{ secrets.APPLE_DEVELOPER_CERTIFICATE_PASSWORD }}
- name: Sign our macOS binary
  if: matrix.platform == 'macos-latest'
  run: |
    echo "Signing Package"
    gon -log-level=info ./build/darwin/gon-sign.json
    p12-密码：${{ secrets.APPLE_DEVELOPER_CERTIFICATE_PASSWORD }}
- 名称：在矩阵中签名我们的 macOS 二进制
  latform == 'macos-latest'
  run: |
    echo "Signing Package"
    gon -log-level=info ./build/darwin/gon-sign.json
```
Please note that signing binaries with Apple could take anywhere from minutes to hours.

## Combined workflow file:
Here is our GitHub workflow file with Windows + macOS combined:
```yaml
名称：“示例组合”
于：
  workflow_paich：
  # 此操作仅在您前往动作并手动运行工作流程时开始。

name: "example"
on:
  workflow_dispatch:
    # This Action only starts when you go to Actions and manually run the workflow.

jobs:
  package:
    strategy:
      matrix:
        platform: [ windows-latest, macos-latest ]
        go-version: [1.18]
    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v2
      - name: Install Go
        uses: actions/setup-go@v2
        with:
          go-version: ${{ matrix.go-version }}
      - name: setup node
        uses: actions/setup-node@v2
        with:
          node-version: 14
      # You may need to manually build you frontend manually here, unless you have configured frontend build and install commands in wails.json.
      - name: Get Wails
        run: go install github.com/wailsapp/wails/v2/cmd/wails@latest
      - name: Build Wails app
        run: |
          wails build
      - name: upload artifacts macOS
        if: matrix.platform == 'macos-latest'
        uses: actions/upload-artifact@v2
        with:
          name: wails-binaries-macos
          path: build/bin/*
      - name: upload artifacts windows
        if: matrix.platform == 'windows-latest'
        uses: actions/upload-artifact@v2
        with:
          name: wails-binaries-windows
          path: build/bin/*
      - 名称: Get Wails
        run：去安装 github。 om/wailsapp/wails/v2/cmd/wails@latest
      - 名称: Building Wails应用程序
        run: |
          wailbuild
      - 名称: MacOS 下载gon for code signing and app公证
        if 矩阵。 latform == 'macos-latest'
        run: |
          brew install mitchellh/gon/gon
      - 名称: 导入 macOS 的代码签名证书
        如果是矩阵的话。 latform == 'macos-latest'
        uses: Apple-Actions/import-codesign-certs@v1
        with
          # PKCS12 文件中的证书编码为base64 字符串
          p12-file-base64: ${{ secrets.APPLE_DEVELOPER_CERTIFICATE_P12_BASE64 }}
          # 用于导入PKCS12 文件的密码。
          p12-密码：${{ secrets.APPLE_DEVELOPER_CERTIFICATE_PASSWORD }}
      - 名称：在矩阵中签名我们的 macOS 二进制
        latform == 'macos-latest'
        run: |
          echo "签名包"
          gon -log-level=info build/darwin/gon-sign.json
      - 名称：签名Windows binaries
        if 矩阵。 latform == 'windows-latest'
        run: |
          echo "创建证书文件"
          新项目 -ItemType 目录-路径证书
          Set-Content -Path certificate\certificate. xt -值 '${{ secrets.WIN_SIGNING_CERT }}'
          certutil -decode certil \certificate.txt certificate\certificate\certil fx
          echo "Signing our binaries"
          & 'C:/Program Files (286)/Windows Kits/10/bin/10. 7763.0/x86/signtool.exe' sign/fd sha256/tr http://ts. sl.com /f certificate\certificate.pfx /p '${{ secrets.WIN_SIGNING_CERT_PASSWORD }}' .\build\bin\Monitor. xe
      - 名称：上传伪装macOS
        如果矩阵的话。 latform == 'macos-latest'
        uses: actions/upload-artifact@v2
        with
          name: wails-binaries-macos
          path: build/bin/*
      - 名称: 上传伪影窗
        if 矩阵: latform == 'windows-latest'
        uses: actions/upload-artifact@v2
        with
          name: wails-binaries-winds
          path: build/bin/*
```

# End notes
This guide inspired by the RiftShare project and its workflow, which is highly recommended to check out [here](https://github.com/achhabra2/riftshare/blob/main/.github/workflows/build.yaml).