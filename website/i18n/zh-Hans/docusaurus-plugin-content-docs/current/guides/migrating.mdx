
# 从 v1 迁移

## 概览

Wails v2与v1相比有很大变化。 本文件旨在突出现有项目的变化和迁移步骤。

### 创建应用程序

In v1, the main application is created using `wails.CreateApp`, bindings are added with `app.Bind`, then the application is run using `app.Run()`.

示例：

```go title="v1"
 App := wails.CreateApp(&wails. ppConfig@un.org
    标题：“MyApp”，
    宽度：1024，
    高度：768，
    JS: js,
    CS: css,
    颜色: "#131313",
  })
  应用。 ind(basic)
  app.Run()
```

在 v2 中，只有一个方法， `wails.Run()`, 接受 [应用程序选项](../reference/options.mdx#application-options)。

```go title="v2"
    err := wails.Run(&options.App@un.org
        标题: "MyApp",
        宽度: 800,
        Height: 600,
        Assets: assets,
        绑定: []interface{}{
            basic,
        },
})
```

### 绑定中

在诉状中，可以对任意的功能和结构加以约束。 在v2中，这已经简化为仅有约束力的结构。 先前在 v1 中传递到 `Bind()` 方法的结构实例， 现在在 `绑定` 的 [应用程序选项](../reference/options.mdx#application-options) 中指定:

```go title="v1"
  应用 := wails.CreateApp(/* 选项*/)
  app.Bind(基本)
```

```go title="v2"
    err := wails.Run(&options.App@un.org
        /* 其他选项 */
        绑定: []interface{}{
            basic,
        },
})
```

在 v1 中，前端在 `wind.backend` 中可以使用绑定的方法。 这已更改为 `windo.go`.``

### 应用生命周期

在 v1, 绑定结构中有2种特殊方法： `WailsInit()` and `WailsShutdown()`。 已将 替换为 3 个生命周期钩子，作为 [应用程序选项](../reference/options.mdx#application-options) 的一部分：

- [OnStartup](../reference/options.mdx#onstartup)
- [OnShutdut](../reference/options.mdx#onshutdown)
- [OnDomReady](../reference/options.mdx#ondomready)

注意： [OnDomReady](../reference/options.mdx#ondomready) 替换了 `wails:ready` 系统事件v1。

这些方法可以是标准功能，但通常的做法是使它们成为一个结构的一部分：

```go title="v2"
    basic := NewBasicApp()
    err := wails.Run(&选项 pp@un.org
        /* 其他选项 */
        Onstartup: basic。 启动，
        OnShutdown：基本。 hutdown,
        OnDomReady: basic.domored,
    })
...
type Basic struct {
    ctx context.Context
}
func (b *Basic) startup(ctx context.Context) {
    b.ctx = ctx
}
...
```

### 运行时间

v2中的运行时间要比v1更丰富，支持菜单、窗口操作 和更好的对话框。 The signature of the methods has changed slightly - please refer the the [Runtime Reference](../reference/runtime/intro.mdx).

在 v1 中， [运行时间](../reference/runtime/intro.mdx) 可以通过传递到 `WailsInit()` 的结构访问。 在v2中，运行时间已移至自己的包裹。 运行时的每个方法都需要 `上下文。Context` 会传递给 [启动](../reference/options.mdx#onstartup) 方法。

```go title="Runtime Example"
package main

import "github.com/wailsapp/wails/v2/pkg/runtime"

type Basic struct {
    ctx context.Context
}

// startup is called at application startup
func (a *App) startup(ctx context.Context) {
    a.ctx = ctx
    runtime.LogInfo(ctx, "Application Startup called!")
}

```

### 资产

v2中最大的 _个更改_ 是如何处理资产。

在v1中，资产通过2个应用程序选项传递：

- `JS` - 应用程序的 Javascript
- `CSS` - 应用程序的 CSS

这意味着生成一个 JS 和 CSS 文件的责任在 开发者。 这基本上需要使用诸如网络包等复杂的包装材料。

在 v2 中，Wails 没有对您的前端资产做任何假设，就像一个web服务器一样。 您所有的应用程序资源都传递给了应用程序选项作为一个 `嵌入.FS`。

**这意味着不需要捆绑您的资产。 将图像编码为 Base64 或 。尝试使用 bundler 配置的黑色艺术来使用自定义字体**

启动时，路径 将扫描给定的 `embed.FS` `索引。 tml` 并使用它的位置作为根路径 作为所有其他应用程序资源-就像一个web服务器一样。

示例：应用程序有以下项目布局。 All final assets are placed in the `frontend/dist` directory:

```shell
.
├── build/
├── frontend/
│   └── dist/
│       ├── index.html
│       ├── main.js
│       ├── main.css
│       └── logo.svg
├── main.go
└── wails.json
```

通过创建一个 `嵌入.FS` 来使用这些资产：

```go title="Assets Example"
//go:embed frontend/dist
var assets embed.FS

func main()
    err := wails.Run(&options. pp@un.org
        /* 其他选项 */
        资产：资产
    })
}
```

当然，如果您想要，可以使用捆绑机。 唯一的要求是使用 `嵌入，将
个最终应用程序资源目录传递给邮件。 S` 在 `Asset` key of the [application options](../reference/options.mdx#application-options) 中。

### 项目配置

在 v1 中，项目配置被存储在项目根目录下的 `project.json` 文件中。 在 v2 中，项目配置保存在项目根目录下的 `wails.json` 文件中。

文件的格式稍有不同。 下面是比较：

<p align="center">

| v1 | v2 | 备注|
| ---------------------------------- | ---------------- | ---------------------------------------------------------------------------------------------------- | |
| 名称 |
| 描述 | 删除|
| 作者 / 名 | 作者 / 名称 | | |
| 作者 / email | |
| 版本 | 版本 | | | | |
| binaryname | outputfilename | 更改|
| 前端/ dir | 删除|
| 前端/安装| 前端：安装 | 更改|
| 前端/ build| 构建| 更改|| 更改||
| 前端/服务| 删除| 删除|
| 前端/服务| 删除|
| 标签| 删除|
| wailsjsdir | 生成波浪漫的目录|
| assetdir | 这通常是推断的，可以留空。 |
| | 重放器 | 用逗号分隔的附加目录列表来监视更改并触发`dev`模式下的重新加载。 这只是一些更先进的资产配置所需要的。 |

</p>

