---
sidebar_position: 4
---

# Menus

可以向Wail项目添加应用程序菜单。 通过定义 [菜单](#menu) 结构和 在 [`菜单`](../reference/options.mdx#menu) 应用程序配置中设置它来实现这个目标 或者通过调用运行时的方法 [MenuSetApplicationMenu](../reference/runtime/menu.mdx#menusetapplicationmenu)

如何创建菜单的示例：

```go
    AppMenu := menu.NewMenu()
    FileMenu := AppMenu.AddSubmenu("File")
    FileMenu.AddText("&Open", keys.CmdOrCtrl("o"), openFile)
    FileMenu.AddSeparator()
    FileMenu.AddText("Quit", keys.CmdOrCtrl("q"), func(_ *menu.CallbackData) {
        runtime.Quit()
    })

    if runtime.GOOS == "darwin" {
    AppMenu.Append(menu.EditMenu())  // on macos platform, we should append EditMenu to enable Cmd+C,Cmd+V,Cmd+Z... shortcut
    }

    err := wails.Run(&options.App{
        Title:             "Menus Demo",
        Width:             800,
        Height:            600,
        Menu:              AppMenu,
        Bind: []interface{}{
            app,
        },
    )
    // ...
````

也可以通过更新菜单结构并调用
[MenuUpdateApplicationMenu](../reference/runtime/menu.mdx#menuupdateapplicationmenu)动态更新菜单。

上面的示例使用辅助方法，但可以手动构建菜单。

## 菜单

菜单是菜单项集合:

```go title="包: github.com/wailsapp/wails/v2/pkg/menu"
类型菜单结构欧洲共同体
    项目 []*菜单项
}
```

对于应用程序菜单，每个菜单项代表单个菜单，如“编辑”。

为建筑菜单提供简单的助手方法：

```go title="Package: github.com/wailsapp/wails/v2/pkg/menu"
func NewMenuFromItems(first *MenuItem, rest ...*MenuItem) *Menu
```

这使得代码的布局更像菜单的布局，而无需在创建菜单项后手动添加。 或者，您可以手动创建菜单项并将其添加到菜单中。

## MenuItem

菜单项代表菜单内的一个项目。

```go title="Package: github.com/wailsapp/wails/v2/pkg/menu"
// 菜单项表示菜单项包含在菜单
类型菜单项结构中的菜单项。
    标签字符串
    角色
    加速器 *keys ccelerator
    类型类型
    禁用bool
    隐藏bool
    已勾选的bool
    子菜单 *菜单
    点击回调
}
```

| 字段          | 类型                       | 注                            |
| ----------- | ------------------------ | ---------------------------- |
| 标签          | 字符串                      | 菜单文本                         |
| Accelerator | [\*键加速器](#accelerator) | 此菜单项的密钥绑定                    |
| 类型          | [类型](#type)              | 菜单项类型                        |
| 已禁用         | 布尔值                      | 禁用菜单项                        |
| Hidden      | 布尔值                      | 隐藏此菜单项                       |
| 已检查         | 布尔值                      | 将选中内容添加到项目 (复选框 & 单选类型)      |
| SubMenu     | [\*菜单](#menu)          | 设置子菜单                        |
| Click       | [Callback](#callback)    | 点击菜单时回调函数                    |
| 作用          | 字符串                      | 为此菜单项定义一个 [角色](#role)。 仅限Mac |

### Accelerator

加速器 (有时称为键盘快捷键) 定义按键和菜单项之间的绑定。 Wails 定义 一个加速器为组合或密钥 + [修改器](#modifier). 它们在 `"github.com/wailsapp/wails/v2/pkg/menu/keys"` 软件包中可用。

示例：

```go title="Package: github.com/wailsapp/wails/v2/pkg/menu/keys"
    // 在Window/Linux上定义Mac和Ctrl-o的 cmd+o
    myShortcon := keys.CmdOrCtrl("o")
```

键是键盘上的任何单个字符，但 `+`除外，它被定义为 `+`。 一些键不能以字符表示，因此可以使用一组命名字符：

- `背空格`
- `tab`
- `返回`
- `输入`
- `跳转`
- `左侧`
- `右侧`
- `上`
- `向下`
- `空格`
- `删除`
- `首页`
- `结束`
- `上页`
- `向下页面`
- `f1`
- `f2`
- `f3`
- `f4`
- `f5`
- `f6`
- `f7`
- `f8`
- `f9`
- `f10`
- `f11`
- `f12`
- `f13`
- `f14`
- `f15`
- `英尺16`
- `英尺17`
- `f18`
- `英尺19`
- `英尺20`
- `f21`
- `f22`
- `f23`
- `f24`
- `英尺25`
- `f26`
- `f27`
- `英尺28`
- `f29`
- `英尺30`
- `f31`
- `f32`
- `英尺33`
- `f34`
- `英尺35`
- `编号锁`

Wail也支持使用 Electron 的相同语法解析加速器。 这对于将加速器存储在 配置文件中是有用的。

示例：

```go title="Package: github.com/wailsapp/wails/v2/pkg/menu/keys"
    // 在 Window/Linux 上 Mac 和 ctrl-o 定义cmd+o
    myShortcut, err := keys.Parse("Ctrl+Option+A")
```

#### Modifier

下面的修饰符是可以与加速器键结合使用的密钥：

```go title="Package: github.com/wailsapp/wails/v2/pkg/menu/keys"
const (
    // CmdOrCtrlKey 代表着Mac 和其他平台上的控制命令
    CmdOrCtrlKey Modifier = "cmdorctrl"
    // OptionOrAltKey 代表Mac 和其他平台上的Alt 选项
    OptionOrAltKey Modifier = "optionoralt"
    // ShiftKey 代表所有系统上的shift键
    ShiftKey Modifier = "
    // ControlKey 代表所有系统上的控制键
    ControlKey Modifier = "ctrl"
)
```
一些辅助方法可用来使用修饰符创建加速器：

```go title="Package: github.com/wailsapp/wails/v2/pkg/menu/keys"
func CmdOrCtrl(密钥字符串) *加速器
真空选项 Ort(密钥字符串) *加速器
真空Shift(密钥字符串) *加速器
真空控制 (密钥字符串) *加速器
```

修饰符可以使用 `keys.Combo(密钥字符串，修改者1 Modifier, 修改者2 Modifier, rest ...Modifier)`:

```go title="Package: github.com/wailsapp/wails/v2/pkg/menu/keys"
    // 定义在 Mac 上的 "Ctrl+Option+A" 和 "Ctrl+Alt+A" 在 Window/Linux
    myShortcon := keys.Combo("a", ControlKey, OptionOrAltKey)
```

### 类型

每个菜单项必须有一个类型，并有5个类型可用：

```go title="Package: github.com/wailsapp/wails/v2/pkg/menu"
const (
    TextType = "Text"
    SeparatorType = "分隔符"
    SubmenuType = "子菜单"
    ChecboxType = "复选框"
    RadioType = "Radio"
)
```

为方便起见，帮手方法可以快速创建一个菜单项：

```go title="Package: github.com/wailsapp/wails/v2/pkg/menu"
func 文本(标签字符串，加速器 *keys.Accederator, 单击Callback) *菜单项
func 分隔符() *菜单项
func Radio(标签字符串，选中布尔，加速器 *keys. ccelerator, click Callback) *菜单项
真空复选框(标签字符串, 勾选布尔, 加速器 *keys.Activerator, 单击Callback) *菜单项
真空子菜单(标签字符串, 菜单*菜单)
```
您也可以直接在菜单上使用"添加"帮助器创建菜单项：

```go title="Package: github.com/wailsapp/wails/v2/pkg/menu"
func (m*Menu) AddText(标签字符串，加速器 *keys. ccelerator, click Callback) *菜单项
func (m *Menu) AddSeparator() *菜单项
func (m *Menu) AddRadio(标签字符串, 选中布尔, 加速器 *keys. ccelerator, click Callback) *菜单项
func(m *菜单) Addeckbox(标签字符串, 选中布尔, 加速器 *keys. ccelerator, click Callback) *菜单项目
func (m *Menu) AddSubMenu(标签字符串, 菜单*菜单) *菜单I
```


无线电群组的注释：无线电群组被定义为菜单中相互毗邻的若干无线电菜单项。 这意味着你不需要按自动分组项目。 然而，这也意味着你不能有彼此相邻的2 个无线电组 - 它们之间必须有一个非无线电项目。

### Callback

每个菜单项可能有一个回调，在点击项目时执行：

```go title="Package: github.com/wailsapp/wails/v2/pkg/menu"
输入 Callbackfunction (*CallbackData)

输入 CallbackData struct 。
    MenuItem *MenuItem
}
```

函数被赋予 `CallbackData` 结构，这个结构显示哪个菜单项触发了回调。 当 使用可能共享回调的无线电组时，这是有用的。

### 作用

:::info 角色

  角色目前只支持在 Mac 上。

:::

菜单项可能具有角色，这基本上是一个预先定义的菜单项。 我们目前支持以下角色：

| 作用     | 描述                                        |
| ------ | ----------------------------------------- |
| 应用菜单角色 | 标准的 Mac 应用程序菜单。 可以使用 `menu.AppMenu()` 创建。 |
| 编辑菜单角色 | 标准的 Mac 编辑菜单。 可以使用 `menu.EditMenu()` 创建。  |

